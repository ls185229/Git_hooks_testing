#!/usr/bin/env expect

# $Id: get_ftp_out.exp 3291 2015-08-28 18:17:58Z bjones $

################################################################################
#
#    File Name - get_ftp_out.exp
#
#    Description - downloads a file or files from a sftp destination
#
#    Arguments - $1 = filename
#                $2 = directory
#
#    Return - 0 = Success
#             1 = Fail
#
#    Usage:   $programName \[ options \]... <arg>...
#         where <arg> is a filename or list of filenames
#         options: -d date (date must be YYYYMMDD)
#                  -f configfile (the configuration file to use)"
#                     (the default config file is upload.cfg)
#                  -l logfile (file destination for script text output)
#                  -m mode (set the mode, e.g., DEV, TEST, QA or PROD)
#                  -v (verbosity, i.e., raises the debug level)
#                  -h (help. displays this list)
#
#    Exit - 1 -
#           2 -
#           3 - DB Error
#
#    Note - requires GetOpts package from tclGetOpts1.1 to be in ~/MASCLRLIB
#
################################################################################

lappend auto_path /clearing/filemgr/MASCLRLIB
package require GetOpts 1.1

source $env(MASCLR_LIB)/masclr_tcl_lib

##package require Oratcl 4.3

## Enviornment Variable ##
##set box $env(SYS_BOX)
##set prod_db $env(IST_DB)
##set prod_auth_db $env(ATH_DB)
##set sysinfo "System: $box \nLocation: $env(PWD) \n\n"

## Global Variable ##
global programName

global ADDL_CMD ARCHIVE_DIR DESTINATION FTP_CMD FTP_OPTION LOG_FILE MODE PASSWORD
global REMOTE_DIR USERNAME debug_level curdate TIMEOUT NO_DELETE RETRIES

set programName [file tail $argv0]
set cfg_file "upload.cfg"

set ADDL_CMD    [dict create]
set ARCHIVE_DIR ""
set DESTINATION ""
set FTP_CMD     "sftp"
set FTP_OPTION  ""
set LOG_FILE    "ftp.log"
set MODE        "PROD"
set PASSWORD    ""
set REMOTE_DIR  ""
set TIMEOUT     30
set USERNAME    ""
set MASCLR::DEBUG_LEVEL 0

###############################################################################
#
#    Procedure Name - usage
#
#    Description - Print the script usage
#
###############################################################################

proc usage {} {
    global programName

    puts "Usage:   $programName \[ options \]... <arg>... "
    puts "     where <arg> is a filename or list of filenames "
    puts "     options: -d date (date must be YYYYMMDD) "
    puts "              -f configfile (the configuration file to use) "
    puts "                 (the default config file is upload.cfg) "
    puts "              -l logfile (destination for script text output) "
    puts "              -m mode (set the mode, e.g., DEV, TEST, QA or PROD) "
    puts "              -v (verbosity, i.e., raises the debug level) "
    puts "              -h (help. displays this list) "
    exit 1
}


################################################################################
#
#    Procedure Name - initDB
#
#    Description - Setup the DB, tables and handles
#
#    Return - exit 3 if any error
#
###############################################################################
proc initDB {} {
    return 0
}

###############################################################################
#
#    Procedure Name - init
#
#    Description - Initialize program arguments
#
###############################################################################

proc init {} {
    global argv argv0
    global programName
    global runDate
    global mode
    global cfg_file
    global optind
    global debug_level
    global curdate

    set runDate [clock format [clock second] -format "%Y%m%d"]
    set debug_level 0

    while { [ set err [ getopt $argv "d:f:hl:m:v" opt optarg ]] } {
        if { $err < 0 } then {
            puts "error: $argv0: $opt "
            usage
            exit 1
        } else {
            switch -exact $opt {
                d {set runDate  $optarg}
                f {set cfg_file $optarg}
                l {set log_file $optarg
                   MASCLR::set_log_file_name $LOG_FILE
                   MASCLR::log_message "Today is: $curdate"
                }
                m {set mode     $optarg}
                v {incr debug_level
                   incr MASCLR::DEBUG_LEVEL}
                h {
                    usage
                    exit 1
                }
            }
        }
    }

    set argv [ lrange $argv $optind end ]
    if {[llength $argv] == 0} {
        usage
        exit 1
    }

    ### Read the config file to get DB params
    readCfgFile $cfg_file

    ### Intitalize database variables
    initDB
}

###############################################################################
#
#    Procedure Name - readCfgFile
#
#    Description -
#
#    Return -
#
###############################################################################

proc readCfgFile {cfg_file_name} {
    global programName

    global ADDL_CMD ARCHIVE_DIR DESTINATION FTP_CMD FTP_OPTION LOG_FILE MODE PASSWORD
    global REMOTE_DIR USERNAME debug_level curdate TIMEOUT NO_DELETE RETRIES

    set clr_db_logon ""

    if {[catch {open $cfg_file_name r} file_ptr]} {
        puts "File Open Err:Cannot open config file $cfg_file_name"
        exit 1
    }

    MASCLR::log_message "readCfgFile {$cfg_file_name}" 2
    set addl_cmd_index 0

    while { [gets $file_ptr line] > -1 } {
            set line_parms [split $line ~]
            MASCLR::log_message "readCfgFile with line: $line" 3
        if {[string range [string trim $line] 0 0] != "#"} {

            switch -exact -- [lindex  $line_parms 0] {
                "ADDL_CMD"      {
                                dict set ADDL_CMD $addl_cmd_index [lindex $line_parms 1]
                                incr addl_cmd_index
                }
                "ARCHIVE_DIR"   { set ARCHIVE_DIR [lindex $line_parms 1] }
                "DESTINATION"   { set DESTINATION [lindex $line_parms 1] }
                "FTP_CMD"       { set FTP_CMD     [lindex $line_parms 1] }
                "FTP_OPTION"    { set FTP_OPTION  [lindex $line_parms 1] }
                "LOG_FILE"      {
                                set LOG_FILE    [lindex $line_parms 1]
                                MASCLR::set_log_file_name $LOG_FILE
                                MASCLR::log_message "Today is: $curdate"
                }
                "MODE"          { set MODE        [lindex $line_parms 1] }
                "NO_DELETE"     { set NO_DELETE   [lindex $line_parms 1] }
                "PASSWORD"      { set PASSWORD    [lindex $line_parms 1] }
                "PORT"          { set PORT        [lindex $line_parms 1] }
                "REMOTE_DIR"    { set REMOTE_DIR  [lindex $line_parms 1] }
                "RETRIES"       { set RETRIES     [lindex $line_parms 1] }
                "TIMEOUT"       { set TIMEOUT     [lindex $line_parms 1] }
                "USERNAME"      { set USERNAME    [lindex $line_parms 1] }

                default {
                    puts "Unknown config parameter [lindex $line_parms 0]"
                }
            }
        }
    }

    close $file_ptr
    MASCLR::log_message "ADDL_CMD   : $ADDL_CMD    " 2
    MASCLR::log_message "ARCHIVE_DIR: $ARCHIVE_DIR " 2
    MASCLR::log_message "DESTINATION: $DESTINATION " 2
    MASCLR::log_message "FTP_CMD    : $FTP_CMD     " 2
    MASCLR::log_message "FTP_OPTION : $FTP_OPTION  " 2
    MASCLR::log_message "LOG_FILE   : $LOG_FILE    " 2
    MASCLR::log_message "MODE       : $MODE        " 2
    MASCLR::log_message "PASSWORD   : $PASSWORD    " 2
    MASCLR::log_message "REMOTE_DIR : $REMOTE_DIR  " 2
    MASCLR::log_message "TIMEOUT    : $TIMEOUT     " 2
    MASCLR::log_message "USERNAME   : $USERNAME    " 2
    dict for {key val} $ADDL_CMD {
        MASCLR::log_message "ADDL_CMD   : $key : $val  " 2
    }

}

###############################################################################
#
#    Procedure Name - bailout
#
#    Description - Used to exit out from the sftp child process
#
#    Return - None
#
###############################################################################

proc bailout {error_code} {
    global loc_path

    send "bye\r"
    exit $error_code
};# end bailout

###############################################################################
#
#    Procedure Name -
#
#    Description -
#
#    Return -
#
###############################################################################

proc transfer_files {file_list} {
    global ADDL_CMD ARCHIVE_DIR DESTINATION FTP_CMD FTP_OPTION LOG_FILE MODE PASSWORD
    global REMOTE_DIR USERNAME debug_level TIMEOUT NO_DELETE RETRIES

    MASCLR::log_message "transfer_files {file_list: $file_list}" 2
    set timeout $TIMEOUT ; #used by expect to set timeout for responses
    set retries_left $RETRIES


    if { "$USERNAME" != "" && "$DESTINATION" != "" } {
        set USER_DEST $USERNAME@$DESTINATION
    } else {
        set USER_DEST $USERNAME$DESTINATION
    }

    spawn $FTP_CMD $FTP_OPTION $USER_DEST

    expect_after {
        "*gnutls_handshake: The request is invalid*" {
            set    user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            if {$retries_left <= 0 } {
                bailout 1
            }
        }
        "*Access fail*"     {
            set    user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            incr retries_left -1
            if {$retries_left <= 0 } {
                bailout 1
            }
        }
        "*Fatal error*" {
            set    user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            bailout 1
        }
        "*no such file*" {
            set    user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            bailout 1
        }
        "*Unknown command*" {
            set    user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            bailout 1
        }
        timeout      {
            set    user_msg "Timed out\n";
            append user_msg "\n    expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n"
            MASCLR::log_message $user_msg;
            if {$retries_left <= 0 } {
                bailout 2
            }

        }
    }

    while 1 { expect {
        "*assword:"  {send "$PASSWORD\r"}
        "\n530*"     {MASCLR::log_message "failed login\n"; bailout 1}
        "*ftp*>"     {MASCLR::log_message "successful login\n";break}
    } }
    MASCLR::log_message "expect_out(0,string): \n\>\>\>$expect_out(0,string)\<\<\<\n" 3
    MASCLR::log_message "expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n" 3

    dict for {key val} $ADDL_CMD {
        MASCLR::log_message "key:$key, val:$val" 3
        send "$val \r"
        while 1 { expect {
            "*ftp*>"            {break}
        } }
        MASCLR::log_message "ADDL_CMD expect_out(0,string): \n\>\>\>$expect_out(0,string)\<\<\<\n" 3
        MASCLR::log_message "ADDL_CMD expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n" 3
    }

    if { "$REMOTE_DIR" != "" } {
        send "cd $REMOTE_DIR \r"

        while 1 { expect {
            "*ftp*>"   {MASCLR::log_message "changed remote directory\n"; break}
        } }
        MASCLR::log_message "expect_out(0,string): \n\>\>\>$expect_out(0,string)\<\<\<\n" 3
        MASCLR::log_message "expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n" 3
    }

    foreach file_2_transfer $file_list {

        set retries_left $RETRIES
        while {$retries_left > 0} {

            send "get $file_2_transfer\r"
            while 1 { expect {
                "*ftp*>" {
                    MASCLR::log_message "\n $file_2_transfer transferred\n\n";
                    set retries_left 0
                    if { $NO_DELETE == "Y" } {
                        exec touch $file_2_transfer.delete
                    }
                    break
                }
            } }
            MASCLR::log_message "expect_out(0,string): \n\>\>\>$expect_out(0,string)\<\<\<\n" 3
            MASCLR::log_message "expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n" 3

            incr retries_left -1
        }

        if { $NO_DELETE == "Y" && [file exists $file_2_transfer.delete]} {

            set retries_left $RETRIES
            while {$retries_left > 0} {

                send "put $file_2_transfer.delete\r"
                while 1 { expect {
                    "*ftp*>" {
                        set retries_left 0
                        MASCLR::log_message "\n $file_2_transfer.delete transferred\n\n";
                        break
                    }
                } }
                MASCLR::log_message "expect_out(0,string): \n\>\>\>$expect_out(0,string)\<\<\<\n" 3
                MASCLR::log_message "expect_out(buffer)  : \n\>\>\>$expect_out(buffer)\<\<\<\n" 3
                incr retries_left -1
            }
        }
    }

    send "bye\r"

}

##########
## MAIN ##
##########

## log_file
set curdate [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]
MASCLR::set_log_file_name $LOG_FILE
MASCLR::log_message "Command: $argv0 $argv"

init

if { $argv != {} } {
    transfer_files $argv
}
