#!/usr/local/bin/tclsh

package require -exact Oratcl 4.3

#declearing variables for commandline arguments.

set inst_id [lindex $argv 0]
set tsk_nbr [lindex $argv 1]
set sact [lindex $argv 2]
set box "PROD"

#declearing all the date format required.

set logdate [clock seconds]
set logdate [clock format $logdate -format "%Y%m%d%H%M%S"]
set curdate [clock seconds]
set curtime [clock format $curdate -format "%H%M%S"]
set curdate [clock format $curdate -format "%Y%m%d"]
set cdate [clock seconds]
set cdate [clock format $cdate -format "%Y%m%d%H%M%S"]

#standered out for log tracking.

puts " "
puts "----- NEW LOG -------------- $logdate ----------------------"
puts "----- Updating MAS task CMD : $tsk_nbr --------------------------------------"


#declearing few veriables.

set r_hr [clock seconds]
set r_hr [clock format $r_hr -format "%H"]
set r_min [clock seconds]
set r_min [clock format $r_min -format "%M"]
set cparam ""

#Checking we have required command line arguments.

if {$argc < 3 && $tsk_nbr == "102"} {
puts "REQUIRED arguments missing: E.G. argv 0) institution_id, 1) task_nbr 2) settle account number (required for CMD_NBR 102 for all institution)"
exit 1
}

#Checking if a process stop file exist. If process stop file exists stoping process and notifying process issue exists. If the the stop file do not exist
#create the stop file while running this script, so that other process do not start if this scripts completes successfully and removes the stop file at 
#the end of the scripts.

if {[file exists /clearing/filemgr/process.stop]} {
exec echo "PREVIOUS PROCESS NOT COMPLETED ALL OTHER PROCESSES STOPED : Msg sent from sch_cmd.tcl\n FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr" | mailx -r clearing@jetpay.com -s "$box URGENT!!! CALL SOMEONE :: PREVIOUS PROCESS NOT COMPLETED" clearing@jetpay.com assist@jetpay.com
exit 1
} else {
catch {open /clearing/filemgr/process.stop {WRONLY CREAT}} fileid
}

#Declearing a switch to remove zero from infront of time variable to avoid octal format.

switch $r_hr {
    "01" {set t_hr 1}
    "02" {set r_hr 2}
    "03" {set r_hr 3}
    "04" {set r_hr 4}
    "05" {set r_hr 5}
    "06" {set r_hr 6}
    "07" {set r_hr 7}
    "08" {set r_hr 8}
    "09" {set r_hr 9}
      default {set r_hr $r_hr}
}

#Declearing a switch to remove zero from infront of time variable to avoid octal format.

switch $r_min {
    "00" {set r_min 1}
    "01" {set r_min 2}
    "02" {set r_min 3}
    "03" {set r_min 4}
    "04" {set r_min 5}
    "05" {set r_min 6}
    "06" {set r_min 7}
    "07" {set r_min 8}
    "08" {set r_min 9}
    "09" {set r_min 10}
      default {set r_min $r_min}
}


#If current minute is 59 rolling the time to hour with 1st minute.

if {$r_min > 57} {
switch $r_min {
     "58" {set r_min 1
                set r_hr [expr $r_hr + 1]}
     "59" {set r_min 1 
		set r_hr [expr $r_hr + 1]}
 }
}

#Adding 2 additional minutes for any updates to complete.

set r_min [expr $r_min + 2]



#Making sure format is correct. 

set r_hr [format %2d $r_hr]
set r_min [format %2d $r_min]

#Procedure for connecting to DB.

proc connect_to_db {} {
    global db_logon_handle db_connect_handle box
    if {[catch {set db_logon_handle [oralogon masclr/masclr@masclr]} result] } {
        puts "Encountered error $result while trying to connect to DB"
	exec echo "ALL PROCESSES STOPED SINCE sch_cmd.tcl could not logon to DB : Msg sent from sch_cmd.tcl" | mailx -r clearing@jetpay.com -s "$box URGENT!!! CALL SOMEONE :: PROCESS NOT COMPLETED" clearing@jetpay.com assist@jetpay.com
        exit 1
    }
};# end connect_to_db

#Opening connection handle to DB

connect_to_db

#Decleared few variables 

set err ""
set tblnm_ifl "OUT_FILE_LOG"
set tblnm_fvc "FIELD_VALUE_CTRL"
set tigr 1
set cnt 0
set lp 1
global get
global lupdate
set get [oraopen $db_logon_handle]
set lupdate [oraopen $db_logon_handle]

#setting up procedure for time out will take one argument in munber of munites. 

proc timeout {{t 5}} {
set mxrotation [expr $t * 60]
set i 0
while {$i < $mxrotation} {
after 20000
puts -nonewline stdout "."
flush stdout
set i [expr $i + 20]
}
puts stdout " "
}


#Procedure for checking server status

proc chk_sts {} {
global tblnm_fvc
set tblnm_fvc "FIELD_VALUE_CTRL"
global cnt
global tigr
global lp
global get
global lupdate
	set tigr 1
	set cnt 0
	set lp 0

    while {$cnt < 10} {
	set sql1 "select * from $tblnm_fvc where FIELD_NAME like '%R_STATUS'"
	orasql $get $sql1
	puts $cnt
	set cnt [expr $cnt + 1]
	while {[orafetch $get -dataarray z -indexbyname] == 0} {
		puts "$z(FIELD_NAME) = $z(FIELD_VALUE1)"
		set val [string trim $z(FIELD_VALUE1)]
			if {$val != "IDLE"} {
			set tigr 1
			set lp 1
			} 
	}

	if {$lp == 1} {
		after 120000
		set lp 0
	} else {
                        set tigr 0
                        set cnt 15
                        set lp 0
	}
    }

}


#Procedure for check gl date. 
proc chk_gl_date {seq {dt $curdate}} {
global inst_id tsk_nbr chk_sql chk_sql2 get curdate box

set chk_sql "select to_char(MAX(GL_DATE), 'YYYYMMDD') as MAXDT, to_char(MIN(GL_DATE), 'YYYYMMDD') as MINDT from gl_chart_of_acct where institution_id='$inst_id'"
set chk_sql2 "select field_value1 from field_value_ctrl where field_name = 'GL_DATE' and institution_id = '$inst_id'"

orasql $get $chk_sql
orafetch $get -dataarray gl_chk -indexbyname
if {[oramsg $get rc]} {
 exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE value is set to null in table gl_chart_of_acct. Exited GL_EXPORT. CALL Clearing Group IMMIDIATELY." | mailx -r clearing@jetpay.com -s "$box GL_DATE is null" clearing@jetpay.com assist@jetpay.com
return 1
}
if {$gl_chk(MAXDT) != $gl_chk(MINDT)} {
exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n MAX GL_DATE $gl_chk(MAXDT) and MIN GL_DATE $gl_chk(MINDT) values found in table gl_chart_of_acct. Exited GL_EXPORT. CALL Clearing Group IMMIDIATELY." | mailx -r clearing@jetpay.com -s "$box GL_DATE DO not match" clearing@jetpay.com assist@jetpay.com
return 1
}
if {$gl_chk(MAXDT) == $gl_chk(MINDT)} {
	if {$gl_chk(MAXDT) == $dt} {
		return 0
	}
}

orasql $get $chk_sql2
orafetch $get -dataarray gl_chk2 -indexbyname
if {[oramsg $get rc]} {
 exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE value is set to null in table field_value_ctrl and FIELD : field_value1. Exited GL_EXPORT. CALL Clearing Group IMMIDIATELY." | mailx -r clearing@jetpay.com -s "$box GL_DATE is null" clearing@jetpay.com assist@jetpay.com
return 1
}

if {$gl_chk(MAXDT) != $gl_chk2(FIELD_VALUE1)} {
exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n MAX GL_DATE $gl_chk(MAXDT) and FIELD_VALUE1 GL_DATE $gl_chk2(FIELD_VALUE1) values found in table gl_chart_of_acct. Exited GL_EXPORT. CALL Clearing Group IMMIDIATELY." | mailx -r clearing@jetpay.com -s "$box GL_DATE DO not match" clearing@jetpay.com assist@jetpay.com
return 1
}

if {$gl_chk(MAXDT) == $curdate} {
	puts "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE is not set for tomorrow.  GL_DATE = $gl_chk(MAXDT). Running GL_EXPORT"
#        exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE is not set for tomorrow.  GL_DATE = $gl_chk(MAXDT). Running GL_EXPORT" | mailx -r clearing@jetpay.com -s "$box RUNNING GL_EXPORT" clearing@jetpay.com assist@jetpay.com
return 0
}

if {$seq == 1} {
if {$gl_chk(MAXDT) < $curdate} {
exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE is not correct.  GL_DATE = $gl_chk(MAXDT) is less Current date: $curdate" | mailx -r clearing@jetpay.com -s "$box GL_EXPORT is not complete." clearing@jetpay.com assist@jetpay.com
return 1
}
}


if {$seq == 2} {
if {$gl_chk(MAXDT) < $curdate} {
exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE is still not correct.  GL_DATE = $gl_chk(MAXDT) is less that Current date: $curdate" | mailx -r clearing@jetpay.com -s "$box GL_EXPORT is not complete." clearing@jetpay.com assist@jetpay.com
return 1
}
}



if {$gl_chk(MAXDT) > $curdate} {
	set adate [clock format [ clock scan "+1 day" ] -format %Y%m%d]
  if {$seq == 1} {
    if {$gl_chk(MAXDT) == $adate} {
	 puts "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n Alerady has the correct GL_DATE. GL_DATE = $gl_chk(MAXDT)"
#         exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n Alerady has the correct GL_DATE. GL_DATE = $gl_chk(MAXDT)" | mailx -r clearing@jetpay.com -s "$box GL_EXPORT DONE" clearing@jetpay.com assist@jetpay.com
        return 2
    } else {
	 exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE is not correct. GL_DATE = $gl_chk(MAXDT) which is greater than $adate" | mailx -r clearing@jetpay.com -s "$box GL_DATE s greater than $adate" clearing@jetpay.com assist@jetpay.com
        return 1
    }
  }

  if {$seq == 2} {
    if {$gl_chk(MAXDT) == $adate} { 
	 puts "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE UPDATED SUCCSESSFULLY.  GL_DATE = $gl_chk(MAXDT)"
#	 exec echo "FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr.\n GL_DATE UPDATED SUCCSESSFULLY.  GL_DATE = $gl_chk(MAXDT)" | mailx -r clearing@jetpay.com -s "$box GL_EXPORT DONE" clearing@jetpay.com assist@jetpay.com
	return 2
    }
  }
}

}
 

switch $tsk_nbr {

  "100" 	{set cparam "-i$inst_id"}
  "102" 	{set cparam "-i$inst_id -call -d$curdate -t$curtime -oY -f#sact"}
  "105" 	{set cparam "-i$inst_id -call -d$curdate -t$curtime -oY"}
  "106" 	{set cparam "-i$inst_id -d$curdate -t$curtime"}
  "107" 	{set cparam "-i$inst_id -d$curdate"}
  "109" 	{set cparam "-i$inst_id -d$curdate -c1"}
  "110" 	{set cparam "-i$inst_id -d$curdate"}
  "116" 	{set cparam "-i$inst_id -bf1"}
  "118" 	{set cparam "-i$inst_id -cn"}
  "123" 	{set cparam "-i$inst_id -d$curdate"}
  "125" 	{set cparam "-i$inst_id"}
  "130" 	{set cparam "-i$inst_id -c1"}
  "131" 	{set cparam "-i$inst_id -d$curdate"}
  "133" 	{set cparam "-i$inst_id"}
  "138" 	{set cparam "-i$inst_id -d$curdate -c1"}
  "200" 	{set cparam "-i$inst_id"}
  "501" 	{set cparam "-i$inst_id -c1 -d$curdate -t$curtime"}
  "551" 	{set cparam "-i$inst_id -c1"}
  "701" 	{set cparam "-i$inst_id -c1 -d$curdate -t$curtime"}
  "751" 	{set cparam "-i$inst_id -c1"}
  default 	{puts "TASK NUMBER NOT FOUND: TASK SWITCH FAILED: SCRIPT EXITED WITH ERROR"
		exit 1
		}
}


######
#MAIN#
######


#Calling status check Procedure to check server status is Idle.

chk_sts


puts "tigr: $tigr, cnt: $cnt, lp: $lp"
				if {$cnt == 10} {
						set cdate [clock seconds]
						set cdate [clock format $cdate -format "%Y%m%d%H%M%S"]

                                                set sql4 "update tasks set run_hour = '', run_min = '' where institution_id = '$inst_id'"
                                                orasql $lupdate $sql4
                                                puts "SERVER STATUS IS NOT IDLE after 20 munites at $cdate"
                                                exec echo "SERVER STATUS IS NOT IDLE after 20 munites: Tasks reseted to NULL at $cdate" | mailx -r clearing@jetpay.com -s "$box FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr. Failed" clearing@jetpay.com assist@jetpay.com

                                                oracommit $db_logon_handle
							if {[file exists /clearing/filemgr/process.stop]} {
								exit 1
							} else {
								catch {open /clearing/filemgr/process.stop {WRONLY CREAT}} fileid
							}

                                                exit 1

				}

if {$tsk_nbr == "106"} {
if {$tigr == 0} {
global lupdate

set x [chk_gl_date 1]

	switch $x {
		"0"	{puts "Running Gl export"}
		"1"	{puts "Error see email for details."
			 exec /clearing/filemgr/MAS/MAS_CMD/reset_task.tcl >> /clearing/filemgr/MAS/MAS_CMD/task.log
			 exit 1}
		"2"	{puts "Already has the correct GL date."
			 catch {file delete /clearing/filemgr/process.stop} result
			 exit 0
			}
	} 

#updateting mas tasks
		set sql3 "update tasks set run_hour='$r_hr',run_min='$r_min', CMD_PARAM = '$cparam'  where institution_id = '$inst_id' and task_nbr = '$tsk_nbr'"
puts $sql3
		orasql $lupdate $sql3	  
#	exec echo "UPDATE TASK for FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr : $r_hr:$r_min" | mailx -r clearing@jetpay.com -s "$box MAS TASK UPDATED FOR CMD $tsk_nbr" clearing@jetpay.com clearing@jetpay.com assist@jetpay.com
                puts "Time set to run_hour= $r_hr ,run_min= $r_min"
  		oracommit $db_logon_handle

}

timeout

set y [chk_gl_date 2]

        switch $y {
                "0"     {puts "Gl Export did not complete. Please see email."
			 exec /clearing/filemgr/MAS/MAS_CMD/reset_task.tcl >> /clearing/filemgr/MAS/MAS_CMD/task.log
			 exit 0
			}
                "1"     {puts "Error see email for details."
                         exec /clearing/filemgr/MAS/MAS_CMD/reset_task.tcl >> /clearing/filemgr/MAS/MAS_CMD/task.log
                         exit 0}
                "2"     {puts "GL EXPORT SUCCESSFULL."
                        }
        }

} else {

if {$tigr == 0} {
global lupdate
#updateting mas tasks
                set sql3 "update tasks set run_hour='$r_hr',run_min='$r_min', CMD_PARAM = '$cparam'  where institution_id = '$inst_id' and task_nbr = '$tsk_nbr'"
puts $sql3
                orasql $lupdate $sql3
	puts "UPDATE TASK FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr : $r_hr:$r_min"
#        exec echo "UPDATE TASK FOR INST ID: $inst_id :: CMD NBR : $tsk_nbr : $r_hr:$r_min" | mailx -r clearing@jetpay.com -s "$box MAS TASK UPDATED FOR CMD $tsk_nbr" clearing@jetpay.com clearing@jetpay.com assist@jetpay.com
                oracommit $db_logon_handle

}
}
	

catch {file delete /clearing/filemgr/process.stop} result
puts "------------------------------ COMPLETE --------------------------------"
puts " "
