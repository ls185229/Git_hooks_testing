#!/usr/bin/env expect

################################################################################
# $Id: esquire_ach_return_file_dnload.exp 4745 2018-10-12 21:09:48Z bjones $
# $Rev: 4745 $
################################################################################
#
# File Name:  esquire_ach_return_file_dnload.tcl
#
# Description:  This program downloads the ACH return file from Esquire Bank.
#
# Script Arguments:  None.
#
# Output:  None.
#
# Return:   0 = Success
#          !0 = Exit with errors
#
# Notes:  None.
#
################################################################################

#Environment veriables.......

set box $env(SYS_BOX)
set clrpath $env(CLR_OSITE_ROOT)
set maspath $env(MAS_OSITE_ROOT)
set mailtolist $env(MAIL_TO)
set mailfromlist $env(MAIL_FROM)
set clrdb $env(IST_DB)
set authdb $env(ATH_DB)

#Email Subjects variables Priority wise

set msubj_c "$box :: Priority : Critical - Clearing and Settlement"
set msubj_u "$box :: Priority : Urgent - Clearing and Settlement"
set msubj_h "$box :: Priority : High - Clearing and Settlement"
set msubj_m "$box :: Priority : Medium - Clearing and Settlement"
set msubj_l "$box :: Priority : Low - Clearing and Settlement"


#Email Body Headers variables for assist

set mbody_c "ASSIST :: \nContact On-Call Engr. \[15 minutes or Escalate\] - Open Ticket \n\n"
set mbody_u "ASSIST :: \nContact On-Call Engr. \[60 minutes or Escalate\] - Open Ticket \n\n"
set mbody_h "ASSIST :: \nInform On-Call/Available Engr. \[Day Time 7 days of the week\] - Open Ticket \n\n"
set mbody_m "ASSIST :: \nInform Available Engr. \[Day Time 5 working days of week\] - Open Ticket \n\n"
set mbody_l "ASSIST :: \nAssign Ticket to the appropriate Engr. \[24/7 - 365 days\] - Open Ticket \n\n"

#System information variables....

set sysinfo "System: $box\n Location: $env(PWD) \n\n"

# variables used in second portion of the script which prepares a second script to invoke mailx and send the files

global email_to_list
global subject_line
global file_name_pattern
global exception_file_name_pattern
global email_body
global date_offset
global run_as_test
global run_as_test_var_string
global date_of_files
global send_notice


#####################################################################
# return file                                                       #
#####################################################################
proc report_finding_for_dda {subject filename test_run email_to_list} {
    upvar $email_to_list to_list
        if { $test_run == 1 } {
            puts "running as test"
            return
        }
        if { $filename == "" } {
                set result [ exec  mailx  -s "$subject" $to_list ]
        } else {
                set result [ exec uuencode -- $filename "$filename" | mailx  -s "$subject" $to_list]
        }
        puts $result

};# end report_finding_for_dda

#####################################################################
# usage statement                                                   #
#####################################################################
proc usage_statement {} {

    puts "Usage: [info script] ?:date offset?? ?-run_as_test??"
    puts "  where date offset defaults to -1"
    puts "  -run_as_test causes the report file to be created, but the file is not sent to the email list"
    puts "  [info script] is same as [info script] 0"
}

######################################
# set up
######################################

#set file_list {}
#set file_list_for_cmd {}
set date_offset -1

set run_as_test 0
set run_as_test_var_string "-run_as_test"
set send_notice 1
set jpms_email_to_list "clearing@jetpay.com apps@jetpayms.com operations@jetpayms.com accounting@jetpay.com"
set jpis_email_to_list "clearing@jetpay.com isoapps@jetpayiso.com tammy@jetpay.com operations@jetpayms.com accounting@jetpay.com"

set no_offset_provided 1
if { [llength $argv] >= 1 } {
    # should be a number: 0 for current day, -1 for yesterday, -2 for 2 days ago, etc

    # loop through arguments and extract what is relevant
    foreach arg $argv {
    if { [string is integer $arg] } {
        set date_offset $arg
            if { $arg == -1} {
          set no_offset_provided 0
        }
        set no_offset_provided 0
    } elseif { [string equal $arg $run_as_test_var_string] } {
        set run_as_test 1
    } else {
        usage_statement
    }
    }
    puts $date_offset

}
# if no offset was given on the command line, then check to see if this is Monday
# if this is Monday, then the last ACH to report on was on Friday (3 days ago)
if { $no_offset_provided == 1 } {
    send_user "checking day of week"
    send_user "day of week: [clock format [clock seconds] -format "%a"]"
    if { [clock format [clock seconds] -format "%a"] == "Mon" } {

    set date_offset -3
    send_user "Date offset now $date_offset"
    }
}

set date_of_files [clock format [clock scan "[clock format [clock seconds] -format "%y%m%d"] $date_offset day"] -format "%Y%m%d"]
set file_name_pattern "*$date_of_files*" ;# return files indicating success have a pattern of
set exception_file_name_pattern "$date_of_files*.xls" ;# exception files have a format of YYYMMDD_XXXX.xls

# Setup initial variable
set DESTINATION_MACHINE ftp_site_needed_from_esquire

# These allow testing of this script
set USERNAME "username_needed_from_esquire"
set PASSWORD "password_needed_from_esquire"



log_file ftp.log

# Procedure to try to make sure the link is terminated cleanly so the
# ISDN line will drop quickly
proc bailout {error_code} {
        send "bye\r"
        expect {
                "221 Session terminated" {exec sleep 2; exit $error_code}
                timeout                  {exit 99}
        "*ftp>"          {exit 1}
        }
        exit 99
};# end bailout


#**** Main Code Module ****


set timeout 30
spawn sftp $USERNAME@$DESTINATION_MACHINE

while 1 { expect {
    "*assword:"  {send "$PASSWORD\r"}
    "\n530*"           {send_user "failed login\n"; bailout 1}
    "*ftp>"       {send_user "successful login\n";break}
    timeout            {send_user "Timeout problem\n"; bailout 2}
}}

send "mget $file_name_pattern\r"

while 1 {expect {
        "mget*"       {send "y\r";sleep 2}
        #"mput*"       {send "y\r";sleep 2}
        "Fetching" {send_user "Found file(s).  Downloading.\n";sleep 20; break}
    "* not found." {send_user "No files found matching $file_name_pattern"; break }
        #"*Uploading"    {send_user "File appears to be uploading\n"}
    "*ftp>"       {send_user "successful login\n";break}
        timeout         {send_user "Timed out while downloading file\n"; bailout 3}
}}

send "quit\r"

foreach file [glob -nocomplain -- $file_name_pattern] {
    #append file_list_for_cmd "uuencode $file $file; "
    #lappend file_list $file
    if { [string match "*5101*" $file] } {
        if {[string match "NO_CORRECTIONS*" $file]} {
                report_finding_for_dda "No corrections for Esquire ACH file for $date_of_files for Institution 101" $file 0 jpms_email_to_list
        } else {
                report_finding_for_dda "Corrections found for Esquire ACH file for $date_of_files for Institution 101" $file 0 jpms_email_to_list
        }

    } elseif { [string match "*5105*" $file] } {
        if {[string match "NO_CORRECTIONS*" $file]} {
                report_finding_for_dda "No corrections for Esquire ACH file for $date_of_files for Institution 107" $file 0 jpis_email_to_list
        } else {
                report_finding_for_dda "Corrections found for Esquire ACH file for $date_of_files for Institution 107" $file 0 jpis_email_to_list
        }
    } elseif { [string match "*5106*" $file] } {
        if {[string match "NO_CORRECTIONS*" $file]} {
                report_finding_for_dda "No corrections for Esquire ACH file for $date_of_files for Esquire DDA 5106" $file 0 jpms_email_to_list
        } else {
                report_finding_for_dda "Corrections found for Esquire ACH file for $date_of_files for Esquire DDA 5106" $file 0 jpms_email_to_list
        }
    } else {
        report_finding_for_dda "Found unknown ACH return file type from Esquire" $file 0
        # do not run as test if an unknown file type is found.
    }
}


send_user "END ---

Script [info script] complete ----\n"
